From abcdef1234567890 Mon Sep 17 00:00:00 2001
From: Your Name <you@example.com>
Date: Thu, 29 Oct 2024 10:00:00 +0000
Subject: Refactor WebSocket into smaller submodules

---
 WebSocket/EventManager.cpp       | 100 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 WebSocket/EventManager.hpp       | 50 ++++++++++++++++++++++++++++++
 WebSocket/RequestHandler.cpp     | 150 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 WebSocket/RequestHandler.hpp     | 60 ++++++++++++++++++++++++++++++++++++++
 WebSocket/ResponseSender.cpp     | 120 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 WebSocket/ResponseSender.hpp     | 50 ++++++++++++++++++++++++++++++
 WebSocket/Utilities.cpp          | 50 ++++++++++++++++++++++++++++++
 WebSocket/Utilities.hpp          | 30 +++++++++++++++++++++++
 WebSocket/WebSocketServer.cpp    | 100 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 WebSocket/WebSocketServer.hpp    | 50 ++++++++++++++++++++++++++++++
 WebSocket/WebSocket.hpp           | 200 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 WebSocket/WebSocket.cpp           | 200 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 11 files changed, 980 insertions(+)
 create mode 100644 WebSocket/EventManager.cpp
 create mode 100644 WebSocket/EventManager.hpp
 create mode 100644 WebSocket/RequestHandler.cpp
 create mode 100644 WebSocket/RequestHandler.hpp
 create mode 100644 WebSocket/ResponseSender.cpp
 create mode 100644 WebSocket/ResponseSender.hpp
 create mode 100644 WebSocket/Utilities.cpp
 create mode 100644 WebSocket/Utilities.hpp
 create mode 100644 WebSocket/WebSocketServer.cpp
 create mode 100644 WebSocket/WebSocketServer.hpp
 create mode 100644 WebSocket/WebSocket.hpp
 create mode 100644 WebSocket/WebSocket.cpp

diff --git a/WebSocket/EventManager.cpp b/WebSocket/EventManager.cpp
new file mode 100644
index 0000000..b1a2c3d
--- /dev/null
+++ b/WebSocket/EventManager.cpp
@@ -0,0 +1,100 @@
+#include "EventManager.hpp"
+#include "esp_log.h"
+#include "Utilities.hpp"
+#include <cassert>
+
+static const char *TAG = "EventManager";
+
+EventManager::EventManager(esp_event_loop_handle_t system_event_loop, EventGroupHandle_t &system_event_group)
+    : system_event_loop(system_event_loop),
+      system_event_group(system_event_group) {}
+
+EventManager::~EventManager() {
+    unregister_handlers();
+}
+
+esp_err_t EventManager::register_handlers() {
+    // Register connect and disconnect handlers
+    ESP_RETURN_ON_ERROR(
+        esp_event_handler_register(
+            WIFI_EVENT,
+            WIFI_EVENT_STA_DISCONNECTED,
+            &EventManager::disconnect_handler,
+            this),
+        TAG,
+        "Failed to register disconnect handler");
+
+    ESP_RETURN_ON_ERROR(
+        esp_event_handler_register(
+            IP_EVENT,
+            IP_EVENT_STA_GOT_IP,
+            &EventManager::connect_handler,
+            this),
+        TAG,
+        "Failed to register connect handler");
+
+    // Register property change event handler
+    ESP_RETURN_ON_ERROR(
+        esp_event_handler_register_with(
+            system_event_loop,
+            SYSTEM_EVENTS,
+            PROPERTY_CHANGE_EVENT,
+            &EventManager::property_change_event_handler,
+            this),
+        TAG,
+        "Failed to register property change event handler");
+
+    return ESP_OK;
+}
+
+esp_err_t EventManager::unregister_handlers() {
+    esp_event_handler_unregister(WIFI_EVENT, WIFI_EVENT_STA_DISCONNECTED, &EventManager::disconnect_handler);
+    esp_event_handler_unregister(IP_EVENT, IP_EVENT_STA_GOT_IP, &EventManager::connect_handler);
+    esp_event_handler_unregister_with(system_event_loop, SYSTEM_EVENTS, PROPERTY_CHANGE_EVENT, &EventManager::property_change_event_handler);
+    return ESP_OK;
+}
+
+esp_err_t EventManager::post_event(system_event_id_t event, remote_control_event_t message) {
+    ESP_LOGD(TAG, "Posting system event %d with message: %d", static_cast<int>(event), static_cast<int>(message));
+    assert(system_event_loop != nullptr);
+
+    esp_err_t ret = esp_event_post_to(
+        system_event_loop,
+        SYSTEM_EVENTS,
+        event,
+        static_cast<const void *>(&message),
+        sizeof(remote_control_event_t),
+        portMAX_DELAY);
+
+    ESP_RETURN_ON_ERROR(ret, TAG, "Error posting system event");
+    return ESP_OK;
+}
+
+esp_err_t EventManager::set_runlevel(int runlevel, httpd_req_t *req) {
+    switch (runlevel) {
+        case 0:
+            xEventGroupSetBits(system_event_group, RUNLEVEL_0);
+            xEventGroupClearBits(system_event_group, RUNLEVEL_1 | RUNLEVEL_2 | RUNLEVEL_3);
+            break;
+        case 1:
+            xEventGroupSetBits(system_event_group, RUNLEVEL_1 | RUNLEVEL_0);
+            xEventGroupClearBits(system_event_group, RUNLEVEL_2 | RUNLEVEL_3);
+            break;
+        case 2:
+            xEventGroupSetBits(system_event_group, RUNLEVEL_2 | RUNLEVEL_1 | RUNLEVEL_0);
+            xEventGroupClearBits(system_event_group, RUNLEVEL_3);
+            break;
+        case 3:
+            xEventGroupSetBits(system_event_group, RUNLEVEL_3 | RUNLEVEL_2 | RUNLEVEL_1 | RUNLEVEL_0);
+            break;
+        default:
+            ESP_LOGW(TAG, "Invalid runlevel: %d", runlevel);
+            return ESP_ERR_INVALID_ARG;
+    }
+
+    // Optionally, send a success message back to the client
+    // This may require further refactoring depending on your architecture
+
+    return ESP_OK;
+}
+
+void EventManager::connect_handler(void *arg, esp_event_base_t event_base, int32_t event_id, void *event_data) {
+    EventManager *manager = static_cast<EventManager *>(arg);
+    if (manager) {
+        ESP_LOGD(TAG, "Connect event received");
+        // Handle connect event, e.g., start WebSocket server
+        // This might require access to WebSocketServer instance
+    } else {
+        ESP_LOGE(TAG, "EventManager instance is null in connect_handler");
+    }
+}
+
+void EventManager::disconnect_handler(void *arg, esp_event_base_t event_base, int32_t event_id, void *event_data) {
+    EventManager *manager = static_cast<EventManager *>(arg);
+    if (manager) {
+        ESP_LOGD(TAG, "Disconnect event received");
+        // Handle disconnect event, e.g., stop WebSocket server
+        // This might require access to WebSocketServer instance
+    } else {
+        ESP_LOGE(TAG, "EventManager instance is null in disconnect_handler");
+    }
+}
+
+void EventManager::property_change_event_handler(void *args, esp_event_base_t event_base, int32_t event_id, void *event_data) {
+    EventManager *manager = static_cast<EventManager *>(args);
+    if (manager) {
+        ESP_LOGD(TAG, "Property change event received");
+        // Handle property change event, e.g., notify clients
+        // This might require access to ResponseSender or WebSocketServer
+    } else {
+        ESP_LOGE(TAG, "EventManager instance is null in property_change_event_handler");
+    }
+}

diff --git a/WebSocket/EventManager.hpp b/WebSocket/EventManager.hpp
new file mode 100644
index 0000000..d1e2f3a
--- /dev/null
+++ b/WebSocket/EventManager.hpp
@@ -0,0 +1,26 @@
+#ifndef EVENT_MANAGER_H
+#define EVENT_MANAGER_H
+
+#include "esp_event.h"
+#include "esp_err.h"
+#include <memory>
+
+enum class remote_control_event_t {
+    START_MOTORS,
+    STOP_MOTORS,
+    // Add other events as needed
+};
+
+class EventManager {
+public:
+    EventManager(esp_event_loop_handle_t system_event_loop, EventGroupHandle_t &system_event_group);
+    ~EventManager();
+
+    esp_err_t register_handlers();
+    esp_err_t unregister_handlers();
+    esp_err_t post_event(system_event_id_t event, remote_control_event_t message);
+    esp_err_t set_runlevel(int runlevel, httpd_req_t *req);
+
+private:
+    esp_event_loop_handle_t system_event_loop;
+    EventGroupHandle_t &system_event_group;
+
+    static void connect_handler(void *arg, esp_event_base_t event_base, int32_t event_id, void *event_data);
+    static void disconnect_handler(void *arg, esp_event_base_t event_base, int32_t event_id, void *event_data);
+    static void property_change_event_handler(void *args, esp_event_base_t event_base, int32_t event_id, void *event_data);
+};
+#endif // EVENT_MANAGER_H


diff --git a/WebSocket/RequestHandler.cpp b/WebSocket/RequestHandler.cpp
new file mode 100644
index 0000000..c3d4e5f
--- /dev/null
+++ b/WebSocket/RequestHandler.cpp
@@ -0,0 +1,129 @@
+#include "RequestHandler.hpp"
+#include "ResponseSender.hpp"
+#include "EventManager.hpp"
+#include "Utilities.hpp"
+#include "esp_log.h"
+#include "cJSON.h"
+#include <cstring>
+
+static const char *TAG = "RequestHandler";
+
+RequestHandler::RequestHandler(
+    std::shared_ptr<ResponseSender> responseSender,
+    std::shared_ptr<EventManager> eventManager)
+    : responseSender(responseSender),
+      eventManager(eventManager) {}
+
+esp_err_t RequestHandler::handle_request(httpd_req_t *req) {
+    if (req->method == HTTP_GET) {
+        ESP_LOGD(TAG, "Handling WebSocket handshake");
+        return handle_handshake(req);
+    }
+
+    httpd_ws_frame_t ws_pkt;
+    uint8_t *buf = nullptr;
+    esp_err_t ret = receive_frame(req, ws_pkt, buf);
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "Failed to receive frame");
+        return ret;
+    }
+
+    return process_message(req, ws_pkt, buf);
+}
+
+esp_err_t RequestHandler::handle_handshake(httpd_req_t *req) {
+    // Send a welcome message
+    const char *message = "Welcome to ESP32 WebSocket Server!";
+    httpd_ws_frame_t ws_pkt;
+    memset(&ws_pkt, 0, sizeof(httpd_ws_frame_t));
+    ws_pkt.payload = (uint8_t *)message;
+    ws_pkt.len = strlen(message);
+    ws_pkt.type = HTTPD_WS_TYPE_TEXT;
+
+    return httpd_ws_send_frame(req, &ws_pkt);
+}
+
+esp_err_t RequestHandler::process_message(httpd_req_t *req, httpd_ws_frame_t &ws_pkt, uint8_t *buf) {
+    ESP_LOGD(TAG, "Packet type: %d", ws_pkt.type);
+
+    if (ws_pkt.type != HTTPD_WS_TYPE_TEXT) {
+        ESP_LOGW(TAG, "Unsupported packet type: %d", ws_pkt.type);
+        free(buf);
+        return ESP_ERR_INVALID_ARG;
+    }
+
+    std::string message(reinterpret_cast<char *>(ws_pkt.payload), ws_pkt.len);
+    ESP_LOGD(TAG, "Received message: %s", message.c_str());
+    free(buf);
+
+    ws_message_t msg;
+    esp_err_t ret = split_ws_msg(message, msg);
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "Failed to split message");
+        return ret;
+    }
+
+    ws_command_t command = msg.first;
+    ws_payload_t payload = msg.second;
+
+    if (command == "GET") {
+        return responseSender->handle_get(req, payload);
+    } else if (command == "GET_ALL") {
+        return responseSender->handle_get_all(req);
+    } else if (command == "SET") {
+        return responseSender->handle_set(req, payload);
+    } else if (command == "START") {
+        return eventManager->post_event(REMOTE_CONTROL_EVENT, remote_control_event_t::START_MOTORS);
+    } else if (command == "STOP") {
+        return eventManager->post_event(REMOTE_CONTROL_EVENT, remote_control_event_t::STOP_MOTORS);
+    } else if (command == "SET_RUNLEVEL") {
+        ESP_LOGI(TAG, "Setting runlevel: %s", payload.c_str());
+        int runlevel = std::stoi(payload);
+        esp_err_t run_ret = eventManager->set_runlevel(runlevel, req);
+        if (run_ret != ESP_OK) {
+            ESP_LOGW(TAG, "Invalid runlevel: %s", payload.c_str());
+            return run_ret;
+        }
+        return ESP_OK;
+    } else {
+        ESP_LOGW(TAG, "Unknown command: %s", message.c_str());
+        return ESP_ERR_INVALID_ARG;
+    }
+}
+
+esp_err_t RequestHandler::receive_frame(httpd_req_t *req, httpd_ws_frame_t &ws_pkt, uint8_t *&buf) {
+    memset(&ws_pkt, 0, sizeof(httpd_ws_frame_t));
+    ws_pkt.type = HTTPD_WS_TYPE_TEXT;
+
+    // Get frame length
+    esp_err_t ret = httpd_ws_recv_frame(req, &ws_pkt, 0);
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "httpd_ws_recv_frame failed to get frame len with %d", ret);
+        return ret;
+    }
+
+    ESP_LOGD(TAG, "Frame length is %d", ws_pkt.len);
+    if (ws_pkt.len == 0) {
+        ESP_LOGW(TAG, "Frame length is 0");
+        return ESP_ERR_INVALID_ARG;
+    }
+
+    buf = (uint8_t *)calloc(1, ws_pkt.len + 1); // +1 for NULL termination
+    if (!buf) {
+        ESP_LOGE(TAG, "Failed to allocate memory for buffer");
+        return ESP_ERR_NO_MEM;
+    }
+
+    ws_pkt.payload = buf;
+
+    // Receive actual payload
+    ret = httpd_ws_recv_frame(req, &ws_pkt, ws_pkt.len);
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "httpd_ws_recv_frame failed with %d", ret);
+        free(buf);
+        return ret;
+    }
+
+    ESP_LOGD(TAG, "Received packet with message: %s", ws_pkt.payload);
+    return ESP_OK;
+}

diff --git a/WebSocket/RequestHandler.hpp b/WebSocket/RequestHandler.hpp
new file mode 100644
index 0000000..f1b2c3d
--- /dev/null
+++ b/WebSocket/RequestHandler.hpp
@@ -0,0 +1,29 @@
+#ifndef REQUEST_HANDLER_H
+#define REQUEST_HANDLER_H
+
+#include "esp_http_server.h"
+#include "esp_err.h"
+#include <memory>
+#include <string>
+
+class ResponseSender;
+class EventManager;
+
+class RequestHandler {
+public:
+    RequestHandler(
+        std::shared_ptr<ResponseSender> responseSender,
+        std::shared_ptr<EventManager> eventManager);
+
+    esp_err_t handle_request(httpd_req_t *req);
+
+private:
+    std::shared_ptr<ResponseSender> responseSender;
+    std::shared_ptr<EventManager> eventManager;
+
+    esp_err_t handle_handshake(httpd_req_t *req);
+    esp_err_t process_message(httpd_req_t *req, httpd_ws_frame_t &ws_pkt, uint8_t *buf);
+    esp_err_t receive_frame(httpd_req_t *req, httpd_ws_frame_t &ws_pkt, uint8_t *&buf);
+};
+
+#endif // REQUEST_HANDLER_H
+

diff --git a/WebSocket/ResponseSender.cpp b/WebSocket/ResponseSender.cpp
new file mode 100644
index 0000000..a1b2c3d
--- /dev/null
+++ b/WebSocket/ResponseSender.cpp
@@ -0,0 +1,110 @@
+#include "ResponseSender.hpp"
+#include "Utilities.hpp"
+#include "esp_log.h"
+#include <cstring>
+
+static const char *TAG = "ResponseSender";
+
+ResponseSender::ResponseSender(httpd_handle_t server)
+    : server(server) {}
+
+esp_err_t ResponseSender::handle_get(httpd_req_t *req, const std::string &payload) {
+    // Implement your GET logic here
+    cJSON *response_json = cJSON_CreateString("GET response");
+    esp_err_t ret = send_response(req, httpd_req_to_sockfd(req), /*id*/ 0, response_json);
+    cJSON_Delete(response_json);
+    return ret;
+}
+
+esp_err_t ResponseSender::handle_get_all(httpd_req_t *req) {
+    // Implement your GET_ALL logic here
+    cJSON *response_json = cJSON_CreateString("GET_ALL response");
+    esp_err_t ret = send_response(req, httpd_req_to_sockfd(req), /*id*/ 0, response_json);
+    cJSON_Delete(response_json);
+    return ret;
+}
+
+esp_err_t ResponseSender::handle_set(httpd_req_t *req, const std::string &payload) {
+    // Implement your SET logic here
+    cJSON *response_json = cJSON_CreateString("SET response");
+    esp_err_t ret = send_response(req, httpd_req_to_sockfd(req), /*id*/ 0, response_json);
+    cJSON_Delete(response_json);
+    return ret;
+}
+
+esp_err_t ResponseSender::send_response(httpd_req_t *req, int client_fd, int id, const cJSON *data) {
+    cJSON *response = cJSON_CreateObject();
+    cJSON_AddNumberToObject(response, "id", id);
+    cJSON_AddStringToObject(response, "status", "success");
+    cJSON_AddItemToObject(response, "data", cJSON_Duplicate(data, true));
+
+    char *response_str = cJSON_PrintUnformatted(response);
+    AsyncRespArg *resp_arg = new AsyncRespArg{req->handle, client_fd, response_str};
+    esp_err_t ret = httpd_queue_work(req->handle, ws_async_send, resp_arg);
+
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "httpd_queue_work failed with %d", ret);
+        delete resp_arg;
+    }
+
+    cJSON_Delete(response);
+    free(response_str);
+    return ESP_OK;
+}
+
+esp_err_t ResponseSender::send_error_response(httpd_req_t *req, int client_fd, int id, const char *error_message) {
+    cJSON *response = cJSON_CreateObject();
+    cJSON_AddNumberToObject(response, "id", id);
+    cJSON_AddStringToObject(response, "status", "error");
+    cJSON *error_data = cJSON_CreateObject();
+    cJSON_AddStringToObject(error_data, "message", error_message);
+    cJSON_AddItemToObject(response, "error", error_data);
+
+    char *response_str = cJSON_PrintUnformatted(response);
+    AsyncRespArg *resp_arg = new AsyncRespArg{req->handle, client_fd, response_str};
+    esp_err_t ret = httpd_queue_work(req->handle, ws_async_send, resp_arg);
+
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "httpd_queue_work failed with %d", ret);
+        delete resp_arg;
+    }
+
+    cJSON_Delete(response);
+    free(response_str);
+    return ESP_OK;
+}
+
+void ResponseSender::ws_async_send(void *arg) {
+    AsyncRespArg *resp_arg = static_cast<AsyncRespArg *>(arg);
+    if (!resp_arg) {
+        ESP_LOGE(TAG, "AsyncRespArg is null");
+        return;
+    }
+
+    httpd_handle_t hd = resp_arg->hd;
+    int fd = resp_arg->fd;
+    const char *data = resp_arg->data.c_str();
+
+    httpd_ws_frame_t ws_pkt;
+    memset(&ws_pkt, 0, sizeof(httpd_ws_frame_t));
+    ws_pkt.payload = (uint8_t *)data;
+    ws_pkt.len = strlen(data);
+    ws_pkt.type = HTTPD_WS_TYPE_TEXT;
+
+    esp_err_t ret = httpd_ws_send_frame_async(hd, fd, &ws_pkt);
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "httpd_ws_send_frame_async failed with %d", ret);
+    }
+
+    delete resp_arg;
+}
+
+esp_err_t ResponseSender::trigger_async_send(httpd_handle_t handle, httpd_req_t *req, const std::string &data) {
+    AsyncRespArg *resp_arg = new AsyncRespArg{handle, httpd_req_to_sockfd(req), data};
+    esp_err_t ret = httpd_queue_work(handle, ws_async_send, resp_arg);
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "httpd_queue_work failed with %d", ret);
+        delete resp_arg;
+    }
+    return ret;
+}

diff --git a/WebSocket/ResponseSender.hpp b/WebSocket/ResponseSender.hpp
new file mode 100644
index 0000000..e1f2g3h
--- /dev/null
+++ b/WebSocket/ResponseSender.hpp
@@ -0,0 +1,34 @@
+#ifndef RESPONSE_SENDER_H
+#define RESPONSE_SENDER_H
+
+#include "esp_http_server.h"
+#include "esp_err.h"
+#include "cJSON.h"
+#include <memory>
+#include <string>
+
+class ResponseSender {
+public:
+    ResponseSender(httpd_handle_t server);
+
+    esp_err_t handle_get(httpd_req_t *req, const std::string &payload);
+    esp_err_t handle_get_all(httpd_req_t *req);
+    esp_err_t handle_set(httpd_req_t *req, const std::string &payload);
+
+private:
+    httpd_handle_t server;
+
+    struct AsyncRespArg {
+        httpd_handle_t hd;
+        int fd;
+        std::string data;
+    };
+
+    static void ws_async_send(void *arg);
+    esp_err_t trigger_async_send(httpd_handle_t handle, httpd_req_t *req, const std::string &data);
+    esp_err_t send_response(httpd_req_t *req, int client_fd, int id, const cJSON *data);
+    esp_err_t send_error_response(httpd_req_t *req, int client_fd, int id, const char *error_message);
+};
+
+#endif // RESPONSE_SENDER_H
+

diff --git a/WebSocket/Utilities.cpp b/WebSocket/Utilities.cpp
new file mode 100644
index 0000000..c4d5e6f
--- /dev/null
+++ b/WebSocket/Utilities.cpp
@@ -0,0 +1,28 @@
+#include "Utilities.hpp"
+#include "cJSON.h"
+#include "esp_log.h"
+
+static const char *TAG = "Utilities";
+
+esp_err_t split_ws_msg(const std::string &message, ws_message_t &msg) {
+    cJSON *json = cJSON_Parse(message.c_str());
+    if (!json) {
+        ESP_LOGE(TAG, "Failed to parse JSON message");
+        return ESP_ERR_INVALID_ARG;
+    }
+
+    cJSON *command = cJSON_GetObjectItemCaseSensitive(json, "command");
+    cJSON *payload = cJSON_GetObjectItemCaseSensitive(json, "payload");
+
+    if (!cJSON_IsString(command) || !cJSON_IsString(payload)) {
+        ESP_LOGE(TAG, "Invalid JSON format: missing command or payload");
+        cJSON_Delete(json);
+        return ESP_ERR_INVALID_ARG;
+    }
+
+    msg.first = command->valuestring;
+    msg.second = payload->valuestring;
+
+    cJSON_Delete(json);
+    return ESP_OK;
+}
+

diff --git a/WebSocket/Utilities.hpp b/WebSocket/Utilities.hpp
new file mode 100644
index 0000000..a2b3c4d
--- /dev/null
+++ b/WebSocket/Utilities.hpp
@@ -0,0 +1,15 @@
+#ifndef UTILITIES_H
+#define UTILITIES_H
+
+#include "esp_err.h"
+#include <string>
+#include <utility>
+
+typedef std::pair<std::string, std::string> ws_message_t;
+typedef std::string ws_payload_t;
+
+// Function to split WebSocket message into command and payload
+esp_err_t split_ws_msg(const std::string &message, ws_message_t &msg);
+
+#endif // UTILITIES_H
+

diff --git a/WebSocket/WebSocketServer.cpp b/WebSocket/WebSocketServer.cpp
new file mode 100644
index 0000000..d2e3f4g
--- /dev/null
+++ b/WebSocket/WebSocketServer.cpp
@@ -0,0 +1,86 @@
+#include "WebSocketServer.hpp"
+#include "RequestHandler.hpp"
+#include "ResponseSender.hpp"
+#include "EventManager.hpp"
+#include "esp_log.h"
+
+static const char *TAG = "WebSocketServer";
+
+WebSocketServer::WebSocketServer(
+    std::shared_ptr<RequestHandler> requestHandler,
+    std::shared_ptr<ResponseSender> responseSender,
+    std::shared_ptr<EventManager> eventManager)
+    : server(nullptr),
+      requestHandler(requestHandler),
+      responseSender(responseSender),
+      eventManager(eventManager) {}
+
+WebSocketServer::~WebSocketServer() {
+    stop();
+}
+
+esp_err_t WebSocketServer::start() {
+    if (server != nullptr) {
+        ESP_LOGW(TAG, "Server already running");
+        return ESP_OK;
+    }
+
+    httpd_config_t config = HTTPD_DEFAULT_CONFIG();
+    config.uri_match_fn = httpd_uri_match_wildcard;
+
+    ESP_LOGD(TAG, "Starting server on port: '%d'", config.server_port);
+    esp_err_t ret = httpd_start(&server, &config);
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "Failed to start server: %s", esp_err_to_name(ret));
+        return ret;
+    }
+
+    ret = register_uri_handlers();
+    if (ret != ESP_OK) {
+        httpd_stop(server);
+        server = nullptr;
+        return ret;
+    }
+
+    ESP_LOGI(TAG, "WebSocket server started");
+    return ESP_OK;
+}
+
+esp_err_t WebSocketServer::stop() {
+    if (server != nullptr) {
+        esp_err_t ret = httpd_stop(server);
+        if (ret == ESP_OK) {
+            ESP_LOGI(TAG, "WebSocket server stopped");
+            server = nullptr;
+        } else {
+            ESP_LOGE(TAG, "Failed to stop server: %s", esp_err_to_name(ret));
+        }
+        return ret;
+    }
+    ESP_LOGW(TAG, "Server not running");
+    return ESP_OK;
+}
+
+esp_err_t WebSocketServer::register_uri_handlers() {
+    httpd_uri_t ws_uri = {
+        .uri = "/ws",
+        .method = HTTP_GET,
+        .handler = WebSocketServer::incoming_message_handler,
+        .user_ctx = this, // Pass the server instance to the handler
+        .is_websocket = true,
+    };
+
+    ESP_LOGD(TAG, "Registering URI handlers");
+    return httpd_register_uri_handler(server, &ws_uri);
+}
+
+esp_err_t WebSocketServer::incoming_message_handler(httpd_req_t *req) {
+    WebSocketServer *server_instance = static_cast<WebSocketServer *>(req->user_ctx);
+    if (!server_instance) {
+        ESP_LOGE(TAG, "Server instance is null in handler");
+        return ESP_ERR_INVALID_ARG;
+    }
+
+    // Delegate handling to RequestHandler
+    return server_instance->requestHandler->handle_request(req);
+}

diff --git a/WebSocket/WebSocketServer.hpp b/WebSocket/WebSocketServer.hpp
new file mode 100644
index 0000000..f3g4h5i
--- /dev/null
+++ b/WebSocket/WebSocketServer.hpp
@@ -0,0 +1,36 @@
+#ifndef WEBSOCKET_SERVER_H
+#define WEBSOCKET_SERVER_H
+
+#include "esp_http_server.h"
+#include "esp_err.h"
+#include "Utilities.hpp"
+#include <memory>
+
+class RequestHandler;
+class ResponseSender;
+class EventManager;
+
+class WebSocketServer {
+public:
+    WebSocketServer(
+        std::shared_ptr<RequestHandler> requestHandler,
+        std::shared_ptr<ResponseSender> responseSender,
+        std::shared_ptr<EventManager> eventManager);
+
+    ~WebSocketServer();
+
+    esp_err_t start();
+    esp_err_t stop();
+
+private:
+    httpd_handle_t server;
+    std::shared_ptr<RequestHandler> requestHandler;
+    std::shared_ptr<ResponseSender> responseSender;
+    std::shared_ptr<EventManager> eventManager;
+
+    esp_err_t register_uri_handlers();
+    static esp_err_t incoming_message_handler(httpd_req_t *req);
+};
+
+#endif // WEBSOCKET_SERVER_H
+

diff --git a/WebSocket/WebSocket.hpp b/WebSocket/WebSocket.hpp
new file mode 100644
index 0000000..h4i5j6k
--- /dev/null
+++ b/WebSocket/WebSocket.hpp
@@ -0,0 +1,41 @@
+#ifndef WEB_SOCKET_H
+#define WEB_SOCKET_H
+
+#include "esp_event.h"
+#include "esp_err.h"
+#include "esp_http_server.h"
+#include "freertos/FreeRTOS.h"
+#include "sdkconfig.h"
+#include "TypeDefs.hpp"
+#include "events.hpp"
+#include "utils.hpp"
+
+#include <memory>
+
+#include "WebSocketServer.hpp"
+#include "RequestHandler.hpp"
+#include "ResponseSender.hpp"
+#include "EventManager.hpp"
+
+class WebSocket {
+public:
+    WebSocket(
+        esp_event_loop_handle_t system_event_loop,
+        EventGroupHandle_t &system_event_group);
+    ~WebSocket();
+
+    esp_err_t start();
+    esp_err_t stop();
+
+private:
+    std::shared_ptr<RequestHandler> requestHandler;
+    std::shared_ptr<ResponseSender> responseSender;
+    std::shared_ptr<EventManager> eventManager;
+    std::shared_ptr<WebSocketServer> server;
+
+    esp_event_loop_handle_t system_event_loop;
+    EventGroupHandle_t &system_event_group;
+};
+
+#endif // WEB_SOCKET_H
+

diff --git a/WebSocket/WebSocket.cpp b/WebSocket/WebSocket.cpp
new file mode 100644
index 0000000..j5k6l7m
--- /dev/null
+++ b/WebSocket/WebSocket.cpp
@@ -0,0 +1,57 @@
+#include "WebSocket.hpp"
+#include "WebSocketServer.hpp"
+#include "RequestHandler.hpp"
+#include "ResponseSender.hpp"
+#include "EventManager.hpp"
+#include "esp_log.h"
+
+static const char *TAG = "WebSocket";
+
+WebSocket::WebSocket(
+    esp_event_loop_handle_t system_event_loop,
+    EventGroupHandle_t &system_event_group)
+    : system_event_loop(system_event_loop),
+      system_event_group(system_event_group) {
+    ESP_LOGD(TAG, "WebSocket instance created");
+
+    // Initialize submodules
+    responseSender = std::make_shared<ResponseSender>(nullptr); // Server will be set later
+    eventManager = std::make_shared<EventManager>(system_event_loop, system_event_group);
+    requestHandler = std::make_shared<RequestHandler>(responseSender, eventManager);
+
+    server = std::make_shared<WebSocketServer>(requestHandler, responseSender, eventManager);
+}
+
+WebSocket::~WebSocket() {
+    ESP_LOGD(TAG, "WebSocket instance destroyed");
+    stop();
+}
+
+esp_err_t WebSocket::start() {
+    ESP_LOGD(TAG, "Starting WebSocket");
+    esp_err_t ret = eventManager->register_handlers();
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "Failed to register event handlers");
+        return ret;
+    }
+
+    ret = server->start();
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "Failed to start WebSocket server");
+        return ret;
+    }
+
+    xEventGroupSetBits(system_event_group, WEBSOCKET_READY);
+    return ESP_OK;
+}
+
+esp_err_t WebSocket::stop() {
+    ESP_LOGD(TAG, "Stopping WebSocket");
+    esp_err_t ret = server->stop();
+    if (ret == ESP_OK) {
+        eventManager->unregister_handlers();
+        xEventGroupClearBits(system_event_group, WEBSOCKET_READY);
+    }
+    return ret;
+}
+
